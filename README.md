# The Container Appliance Framework (CAF)
CAF is an opinionated set of building blocks for creating and deploying portable micro servers using
Git as a delivery vehicle. These "appliances" can be developer sandboxes or small servers that act as
gateways for B2B or other enterprise applications.

Prerequisites:

* Ubuntu 18.04+ LTS server
* user with sudo privileges

Install basic utilities:

    sudo apt install make git net-tools curl wget

Intial setup:

    git clone https://github.com/shah/container-appliance-framework CAF
    cd CAF

    make switch-to-zsh

Exit the shell, log back in.
*If you are greeted with a Zsh shell configuration prompt, select "2" to accept default settings.*

Exit the shell again, log back in. Then:

    cd CAF
    make install-oh-my-zsh

Exit the shell, log back in. Then:

    cd CAF
    make setup-oh-my-zsh

Exit the shell, log back in. Then:

    cd CAF
    make check-dependencies

Follow instructions to install all dependencies.

## Conventions

CAF manages Docker containers using git, make, and [Jsonnet](https://jsonnet.org/). All developers looking
to extend CAF need to know those tools very well. The framework manages containers by an *opinionated* set 
of *conventions*:

* The CAF_HOME/conf, CAF_HOME/lib, and CAF_HOME/shell directories are special
* Other than the special directories mentioned above, all other directories are a *container* definition
  home ("CDH") directory.
* Each **CDH** directory symbolically links a Makefile to CAF_HOME/lib/Makefile.container.
* Each **CDH** directory holds, at a minium, a container.defn.jsonnet config file
* Each **CDH** directory holds a .gitignore file which is auto-generated by the Makefile
  and makes sure that no git tracking occurs for files generated by Jsonnet.
* The CDH directory's Makefile feeds Jsonnet a container.defn.jsonnet and generates all necessary
  Docker artifacts.

## CAF Makefile

The job of the CAF_HOME/Makefile is to help setup the Docker engine and a minimal set of dependencies. This
Makefile should probably be replaced by Ansible, Puppet, or maybe Docker Machine in the future.

## Container Makefile

Each container definition home directory contains a Makefile which is, usually, symlink'd to
CAF_HOME/lib/Makefile.container. This allows each container to have it's own Makefile but conveniently
links to a master Makefile unless the container has something special.

The Makefile has a simple plugin model:

* If a file named **after_configure.make-plugin.sh** exists in the container definition home directory,
  it is run right after the Makefile's configure target (after generating all artifacts).
* If a file named **container.make.inc** exists in the container definition home directory, it is
  included in the Makefile -- effectively allowing you to add targets. You can also redefine targets
  but you'll get a warning.
* If a file named **after_start.make-plugin.sh** exists in the container definition home directory, it
  is run immediately after the make start target concludes. This allows you to run some post-start
  functionality like checking the health of a container or ensuring other dependencies are executed.

The Makefile has these typical targets:

* **help** shows all the targets available in the Makefile -- use that instead of this document when possible
* **build** builds the container using Dockerfile in this directory (if no Dockerfile, this target is ignored)
* **configure** generates the container's artifacts (driven by container.defn.jsonnet), then runs the
  **after_configure.make-plugin.sh** shell script (if it exists)
* **start** runs configure, then starts the container and all dependencies
* **inspect** inspects a running container's settings, volumes, etc.
* **logs** shows the logs in the container
* **ports** shows the container's mapped ports
* **stop** stops the container but retain volumes and generated files
* **kill** stops the container and **DESTRUCTIVELY** removes networks, volumes, etc. but leaves generated files
* **clean** stops the container and **DESTRUCTIVELY** cleans up generated files, networks, volumes, etc.

The Makefile generates these files:

* **.container.defn.jsonnet_generated**, a text file that contains the list of files generated
* **.gitignore**, to make sure generated files are not tracked or committed

## Configuration Files

CAF generates Dockerfile, docker-compose.yml, and a variety of other configuration files using Makefiles
and the [Jsonnet data templating language](https://jsonnet.org/). When Jsonnet runs, it uses the 
JSONNET_JPATH Makefile variable defined in CAF_HOME/lib/Makefile.container.

This is the order of directories that is searched for *.jsonnet files when **import "*file*.conf.jsonnet"**
is called from within a container.defn.jsonnet configuration file:

* CAF_HOME/*container* (the container definition home directory, e.g. CAF_HOME/samba)
* CAF_HOME/conf/secrets
* $HOME/.CAF/conf
* CAF_HOME/../conf ("conf" in the CAF's parent directory)
* CAF_HOME/conf/open
* CAF_HOME/lib

## Secrets Management

The CAF_HOME/conf/secrets directory is where all secrets across all containers are kept. The convention is
to create a file called *container-name*.secrets.jsonnet and place it in the **CAF_HOME/conf/secrets** directory,
which is in the jsonnet path (--jpath in CAF_HOME/lib/Makefile:configure target).

The *container-name*.secrets.conf.jsonnet is then import'd by container.defn.jsonnet in a particular
container. Because --jpath includes the **CAF_HOME/conf/secrets** directory, it will find the secrets jsonnet
configuration files easily.

NOTE: *The CAF_HOME/conf/secrets directory is in CAF_HOME/conf/.gitignore so it will not be tracked by Git.*
To help get started with CAF, the CAF_HOME/Makefile copies lib/secrets-default to CAF_HOME/screts when
the *check-dependencies* target is run.